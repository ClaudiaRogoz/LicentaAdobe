// =================================================================================================
// Copyright 2014 Adobe Systems Incorporated
// All Rights Reserved.
//
// NOTICE:  Adobe permits you to use, modify, and distribute this file in accordance with the terms
// of the Adobe license agreement accompanying it.
// =================================================================================================

#if AdobePrivate
// =================================================================================================
// Change history
// ==============
//
// Writers:
//  HK  Honey Kansal
//  ADC	Amandeep Chawla
//
// mm/dd/yy who Description of changes, most recent on top.
//
// 02-24-14 HK  5.6-c004 Added new internal XMP DOM interfaces + fixed memory leaks + implemented qualifiers for new XMP DOM.
// 02-13-14 ADC 5.5-c031 Refactoring XMPCore, implementing few APIs and fixing issues.
// 02-12-14 HK  5.5-c030 Creating client glue code for XMP DOM APIs.
//
// =================================================================================================
#endif // AdobePrivate

#include "XMPCore/Interfaces/IXMPArrayNode.h"

namespace NS_XMPCORE {


	spcIXMPNode_latest IXMPArrayNode_v1::GetNode( SizeT index ) const{
		CALL_EQUIVALENT_CVIRTUAL_FUNCTION ( IXMPNode, GetNode, index );
	
	}
	spIXMPNode_latest IXMPArrayNode_v1::GetNode( SizeT index ){
		CALL_EQUIVALENT_VIRTUAL_FUNCTION ( IXMPNode, GetNode, index );
	}

	spcIXMPSimpleNode_latest IXMPArrayNode_v1::GetSimpleNode( SizeT index ) const{
		CALL_EQUIVALENT_CVIRTUAL_FUNCTION ( IXMPSimpleNode, GetSimpleNode, index );
	
	}
	spIXMPSimpleNode_latest IXMPArrayNode_v1::GetSimpleNode( SizeT index ){
		CALL_EQUIVALENT_VIRTUAL_FUNCTION ( IXMPSimpleNode, GetSimpleNode, index );
	
	}
	spcIXMPArrayNode_latest IXMPArrayNode_v1::GetArrayNode( SizeT index ) const{
		CALL_EQUIVALENT_CVIRTUAL_FUNCTION ( IXMPArrayNode, GetArrayNode, index );
	}
	spIXMPArrayNode_latest IXMPArrayNode_v1::GetArrayNode( SizeT index ){
		CALL_EQUIVALENT_VIRTUAL_FUNCTION ( IXMPArrayNode, GetArrayNode, index );
	}
	spcIXMPStructNode_latest IXMPArrayNode_v1::GetStructNode ( SizeT index ) const{
		CALL_EQUIVALENT_CVIRTUAL_FUNCTION ( IXMPStructNode, GetStructNode, index );
	}
	spIXMPStructNode_latest IXMPArrayNode_v1::GetStructNode ( SizeT index ){
		CALL_EQUIVALENT_VIRTUAL_FUNCTION ( IXMPStructNode, GetStructNode, index );
	}
	//spcIXMPLanguageAlternative IXMPArrayNode_v1::GetLanguageAlternative( SizeT index ) const{
	//	pIError_latest err( NULL );
	//	pcIXMPLanguageAlternative_base ptr = GetLanguageAlternative( index, err );
	//	if ( err ) {
	//		throw NS_XMPCOMMON::CreateUncheckedSharedPointer( err ) ;
	//	}
	//	return NS_XMPCOMMON::CreateSharedPointer< const IXMPLanguageAlternative_latest, const IXMPLanguageAlternative_base >( ptr );
	//}
	//spIXMPLanguageAlternative IXMPArrayNode_v1::GetLanguageAlternative( SizeT index ){
	//	pIError_latest err( NULL );
	//	pIXMPLanguageAlternative_base ptr = GetLanguageAlternative( index, err );
	//	if ( err ) {
	//		throw NS_XMPCOMMON::CreateUncheckedSharedPointer( err ) ;
	//	}
	//	return NS_XMPCOMMON::CreateSharedPointer< IXMPLanguageAlternative_latest, IXMPLanguageAlternative_base >( ptr );
	//}

	spIXMPSimpleNode_latest IXMPArrayNode_v1::AppendSimpleNode( const char * value ){
		CALL_EQUIVALENT_VIRTUAL_FUNCTION ( IXMPSimpleNode, AppendSimpleNode, value );
	}
	spIXMPArrayNode_latest IXMPArrayNode_v1::AppendArrayNode( eXMPArrayNodeForm form ){
		CALL_EQUIVALENT_VIRTUAL_FUNCTION ( IXMPArrayNode, AppendArrayNode, form );
	}
	spIXMPStructNode_latest IXMPArrayNode_v1::AppendStructNode(){
		CALL_EQUIVALENT_VIRTUAL_FUNCTION_NO_ARGS ( IXMPStructNode, AppendStructNode );
	}
	//spIXMPLanguageAlternative IXMPArrayNode_v1::AppendLanguageAlternative(){
	//	pIError_latest err( NULL );
	//	pIXMPLanguageAlternative_base ptr = AppendLanguageAlternative( err );
	//	if ( err ) {
	//		throw NS_XMPCOMMON::CreateUncheckedSharedPointer( err ) ;
	//	}
	//	return NS_XMPCOMMON::CreateSharedPointer< IXMPLanguageAlternative_latest, IXMPLanguageAlternative_base >( ptr );
	//}

	spIXMPSimpleNode_latest IXMPArrayNode_v1::SetSimpleNode( SizeT index, const char * value ){
		CALL_EQUIVALENT_VIRTUAL_FUNCTION ( IXMPSimpleNode, SetSimpleNode, index, value );
	}
	spIXMPArrayNode_latest IXMPArrayNode_v1::SetArrayNode( SizeT index, eXMPArrayNodeForm form ){
		CALL_EQUIVALENT_VIRTUAL_FUNCTION ( IXMPArrayNode, SetArrayNode, index, form );
	}
	spIXMPStructNode_latest IXMPArrayNode_v1::SetStructNode( SizeT index ){
		CALL_EQUIVALENT_VIRTUAL_FUNCTION ( IXMPStructNode, SetStructNode, index );
	}
	//spIXMPLanguageAlternative IXMPArrayNode_v1::SetLanguageAlternative( SizeT index ){
	//	pIError_latest err( NULL );
	//	pIXMPLanguageAlternative_base ptr = SetLanguageAlternative( index, err );
	//	if ( err ) {
	//		throw NS_XMPCOMMON::CreateUncheckedSharedPointer( err ) ;
	//	}
	//	return NS_XMPCOMMON::CreateSharedPointer< IXMPLanguageAlternative_latest, IXMPLanguageAlternative_base >( ptr );
	//}

	spIXMPSimpleNode_latest IXMPArrayNode_v1::InsertSimpleNode( SizeT index, const char * value ){
		CALL_EQUIVALENT_VIRTUAL_FUNCTION ( IXMPSimpleNode, InsertSimpleNode, index, value );
	}
	spIXMPArrayNode_latest IXMPArrayNode_v1::InsertArrayNode( SizeT index, eXMPArrayNodeForm form ){
		CALL_EQUIVALENT_VIRTUAL_FUNCTION ( IXMPArrayNode, InsertArrayNode, index, form );
	}
	spIXMPStructNode_latest IXMPArrayNode_v1::InsertStructNode( SizeT index ){
		CALL_EQUIVALENT_VIRTUAL_FUNCTION ( IXMPStructNode, InsertStructNode, index );
	}
	//spIXMPLanguageAlternative IXMPArrayNode_v1::InsertLanguageAlternative( SizeT index ){
	//	pIError_latest err( NULL );
	//	pIXMPLanguageAlternative_base ptr = InsertLanguageAlternative( index, err );
	//	if ( err ) {
	//		throw NS_XMPCOMMON::CreateUncheckedSharedPointer( err ) ;
	//	}
	//	return NS_XMPCOMMON::CreateSharedPointer< IXMPLanguageAlternative_latest, IXMPLanguageAlternative_base >( ptr );
	//}

	spIXMPNode_latest IXMPArrayNode_v1::Remove( SizeT index ){
		CALL_EQUIVALENT_VIRTUAL_FUNCTION ( IXMPNode, Remove, index );
	}
		
}
